---
// Garden management interface for booking schedule and holidays
// Moved from /admin to /garden-mgmt for security
---

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Garden Management - BG Bouquet</title>

	<!-- Prevent search engine indexing - CRITICAL SECURITY -->
	<meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
	<meta name="googlebot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
	<meta name="bingbot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
	<meta name="slurp" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
	<meta name="duckduckbot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">

	<!-- Prevent caching -->
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="stylesheet" href="/styles/admin.css">
<link rel="stylesheet" href="/styles/schedule-lock.css">

<style>
  /* Styles for disabled admin sections */
  .section-disabled {
    position: relative;
    opacity: 0.7;
    pointer-events: none;
  }
  
  .section-disabled::before {
    content: "Locked";
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: #f8d7da;
    color: #721c24;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 10;
  }
  
  .section-disabled::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.3);
    z-index: 1;
    pointer-events: none;
    border: 1px dashed #ccc;
    border-radius: 4px;
  }
  
  .section-disabled input,
  .section-disabled select,
  .section-disabled button:not(#lockScheduleBtn):not(#scheduleUpdateBtn) {
    cursor: not-allowed;
  }
  
  .disabled {
    opacity: 0.6;
    cursor: not-allowed !important;
  }
  
  /* Exception for lock controls */
  .schedule-lock-controls {
    opacity: 1 !important;
    pointer-events: all !important;
  }
  
  .schedule-lock-controls button {
    cursor: pointer !important;
  }

  /* Enhanced loading indicators for ALL buttons */
  .btn-spinner {
    display: none;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }

  /* CSS-based spinner icon - more reliable than SVG */
  .spinner-icon {
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    flex-shrink: 0;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* Button loading states */
  .btn:disabled {
    opacity: 0.8;
    cursor: not-allowed !important;
    position: relative;
  }

  .btn:disabled .btn-text {
    display: none;
  }

  .btn:disabled .btn-spinner {
    display: flex;
  }

  /* Maintain button colors when disabled */
  .btn.btn-primary:disabled {
    background-color: #007bff;
    border-color: #007bff;
    color: white;
  }

  .btn.btn-secondary:disabled {
    background-color: #6c757d;
    border-color: #6c757d;
    color: white;
  }

  .btn.btn-warning:disabled {
    background-color: #ffc107;
    border-color: #ffc107;
    color: #212529;
  }

  /* Subtle pulse animation for loading text */
  .btn:disabled .btn-spinner {
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }

  /* Override pulse for spinner icon to keep it spinning */
  .btn:disabled .spinner-icon {
    animation: spin 1s linear infinite;
  }
</style>

<script>
  // Inline the schedule-lock.ts functionality to ensure it's available
  document.addEventListener('DOMContentLoaded', function() {
    // Only initialize if we're on the admin page and logged in
    const checkForAdmin = setInterval(() => {
      const adminContent = document.getElementById('adminContent');
      if (adminContent && !adminContent.classList.contains('hidden')) {
        clearInterval(checkForAdmin);
        initScheduleLockUI();
      }
    }, 500); // Check every 500ms
  });

  async function initScheduleLockUI() {
    // Create a new section for schedule lock controls
    const adminContainer = document.querySelector('.admin-container');
    const pricingSection = document.querySelector('.pricing-section');
    
    if (!adminContainer || !pricingSection) {
      console.error('Required elements not found');
      return;
    }
    
    // Create the schedule lock section
    const lockSection = document.createElement('div');
    lockSection.className = 'admin-section schedule-lock-section';
    lockSection.innerHTML = `
      <h2>Schedule Lock Controls</h2>
      <div class="schedule-lock-controls">
        <div class="lock-status-indicator">
          <div class="lock-status">
            <span class="status-text">Schedule is <span class="unlock-status">unlocked</span><span class="lock-status hidden">locked</span></span>
            <span class="status-indicator unlocked"></span>
          </div>
          <p class="status-description">Customers can currently make bookings. Lock the schedule to make changes.</p>
        </div>
        
        <div class="lock-action-buttons">
          <button id="lockScheduleBtn" class="btn btn-warning">
            <span class="btn-text">Lock Bookings to Edit Schedule</span>
            <span class="btn-spinner">
              <span class="spinner-icon"></span>
              Locking...
            </span>
          </button>
          <button id="scheduleUpdateBtn" class="btn btn-secondary">
            <span class="btn-text">Schedule Update for Later</span>
            <span class="btn-spinner">
              <span class="spinner-icon"></span>
              Scheduling...
            </span>
          </button>
          <button id="applyChangesBtn" class="btn btn-primary hidden">
            <span class="btn-text">Unlock Bookings</span>
            <span class="btn-spinner">
              <span class="spinner-icon"></span>
              Unlocking...
            </span>
          </button>
        </div>
        
        <div id="scheduleLockMessage" class="hidden"></div>
      </div>
      
      <div class="schedule-update-modal hidden" id="scheduleUpdateModal">
        <div class="modal-content">
          <h3>Schedule Update for Later</h3>
          <p>Choose when to apply schedule changes. Booking will not be disrupted until the update time.</p>
          
          <div class="form-group">
            <label for="updateDateTime">Update Date/Time:</label>
            <input type="datetime-local" id="updateDateTime" min="${getMinDateTimeString()}">
            <p class="help-text">Updates are applied in the America/Edmonton timezone.</p>
          </div>
          
          <div class="modal-actions">
            <button id="cancelScheduleUpdateBtn" class="btn btn-secondary">Cancel</button>
            <button id="confirmScheduleUpdateBtn" class="btn btn-primary">
              <span class="btn-text">Schedule Update</span>
              <span class="btn-spinner">
                <span class="spinner-icon"></span>
                Scheduling...
              </span>
            </button>
          </div>
        </div>
      </div>
    `;
    
    // Insert the lock section after the pricing section
    adminContainer.insertBefore(lockSection, pricingSection.nextSibling);
    
    // Set up event handlers
    setupLockEventHandlers();
    
    // Check current lock status
    await checkLockStatus();
  }

  function setupLockEventHandlers() {
    // Lock Schedule button
    document.getElementById('lockScheduleBtn')?.addEventListener('click', lockSchedule);
    
    // Apply Changes button
    document.getElementById('applyChangesBtn')?.addEventListener('click', function() {
      // Show warning about unsaved changes before unlocking
      if (confirm('Any unsaved changes will be lost when unlocking. Continue?')) {
        applyChangesAndUnlock();
      }
    });
    
    // Schedule Update button and modal
    document.getElementById('scheduleUpdateBtn')?.addEventListener('click', showScheduleUpdateModal);
    document.getElementById('cancelScheduleUpdateBtn')?.addEventListener('click', hideScheduleUpdateModal);
    document.getElementById('confirmScheduleUpdateBtn')?.addEventListener('click', scheduleUpdate);
    
    // Hide modal when clicking outside
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('scheduleUpdateModal');
      const target = e.target as HTMLElement;
      if (modal && !modal.classList.contains('hidden') && !modal.contains(target) &&
          target.id !== 'scheduleUpdateBtn') {
        hideScheduleUpdateModal();
      }
    });
  }

  async function checkLockStatus() {
    try {
      setButtonLoading('lockScheduleBtn', true);
      
      const response = await fetch('/api/admin/schedule-lock');
      const data = await response.json();
      
      updateLockStatusUI(data.isLocked, data.scheduledUpdate);
      
      // Initial state: forms are disabled until locked for editing
      if (!data.isLocked) {
        enableAllFormInputs(false);
      }
    } catch (error) {
      console.error('Error checking lock status:', error);
      showLockMessage('Could not check lock status', 'error');
    } finally {
      setButtonLoading('lockScheduleBtn', false);
    }
  }

  function updateLockStatusUI(isLocked: boolean, scheduledUpdate: string | null) {
    const lockStatusText = document.querySelector('.unlock-status');
    const lockingStatusText = document.querySelector('.lock-status');
    const statusIndicator = document.querySelector('.status-indicator');
    const statusDescription = document.querySelector('.status-description');
    const lockButton = document.getElementById('lockScheduleBtn');
    const applyButton = document.getElementById('applyChangesBtn');
    const scheduleButton = document.getElementById('scheduleUpdateBtn');
    
    // Update status text and indicator
    if (lockStatusText && lockingStatusText && statusIndicator && statusDescription) {
      if (isLocked) {
        lockStatusText.classList.add('hidden');
        lockingStatusText.classList.remove('hidden');
        statusIndicator.classList.remove('unlocked');
        statusIndicator.classList.add('locked');
        statusDescription.textContent = 'Bookings are locked. Customers cannot make new bookings while you edit the schedule.';
      } else {
        lockStatusText.classList.remove('hidden');
        lockingStatusText.classList.add('hidden');
        statusIndicator.classList.add('unlocked');
        statusIndicator.classList.remove('locked');
        
        if (scheduledUpdate) {
          const updateTime = new Date(scheduledUpdate).toLocaleString();
          statusDescription.textContent = `Schedule update is planned for ${updateTime}. Customers can continue booking until then.`;
        } else {
          statusDescription.textContent = 'Customers can currently make bookings. Lock bookings to make schedule changes.';
        }
      }
    }
    
    // Update buttons
    if (lockButton && applyButton && scheduleButton) {
      if (isLocked) {
        lockButton.classList.add('hidden');
        applyButton.classList.remove('hidden');
        scheduleButton.classList.add('hidden');
        
        // Enable all form inputs for editing when locked
        enableAllFormInputs(true);
      } else {
        lockButton.classList.remove('hidden');
        applyButton.classList.add('hidden');
        scheduleButton.classList.remove('hidden');
        
        // Disable form inputs when not in edit mode
        enableAllFormInputs(false);
      }
    }
  }

  async function lockSchedule() {
    try {
      setButtonLoading('lockScheduleBtn', true);
      
      const response = await fetch('/api/admin/schedule-lock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'lock' })
      });
      
      const result = await response.json();
      
      if (result.success) {
        updateLockStatusUI(true, null);
        showLockMessage(result.message, 'success');
      } else {
        showLockMessage(result.error || 'Failed to lock schedule', 'error');
      }
    } catch (error) {
      console.error('Error locking schedule:', error);
      showLockMessage('Error locking schedule', 'error');
    } finally {
      setButtonLoading('lockScheduleBtn', false);
    }
  }

  async function applyChangesAndUnlock() {
    try {
      setButtonLoading('applyChangesBtn', true);
      
      const response = await fetch('/api/admin/schedule-lock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'unlock',
          // No settings included - just unlock
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        updateLockStatusUI(false, null);
        showLockMessage('Bookings unlocked. Customers can now make bookings.', 'success');
      } else {
        showLockMessage(result.error || 'Failed to unlock bookings', 'error');
      }
    } catch (error) {
      console.error('Error unlocking bookings:', error);
      showLockMessage('Error unlocking bookings', 'error');
    } finally {
      setButtonLoading('applyChangesBtn', false);
    }
  }

  function showScheduleUpdateModal() {
    const modal = document.getElementById('scheduleUpdateModal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  }

  function hideScheduleUpdateModal() {
    const modal = document.getElementById('scheduleUpdateModal');
    if (modal) {
      modal.classList.add('hidden');
    }
  }

  async function scheduleUpdate() {
    try {
      const dateTimeInput = document.getElementById('updateDateTime') as HTMLInputElement;
      if (!dateTimeInput || !dateTimeInput.value) {
        showLockMessage('Please select a date and time for the update', 'error');
        return;
      }
      
      // Convert to ISO string
      const scheduledTime = new Date(dateTimeInput.value).toISOString();
      
      // Collect all schedule settings
      const settings = collectScheduleSettings();
      
      setButtonLoading('confirmScheduleUpdateBtn', true);
      
      const response = await fetch('/api/admin/schedule-lock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'schedule',
          scheduledTime,
          settings
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        hideScheduleUpdateModal();
        updateLockStatusUI(false, scheduledTime);
        showLockMessage(result.message, 'success');
      } else {
        showLockMessage(result.error || 'Failed to schedule update', 'error');
      }
    } catch (error) {
      console.error('Error scheduling update:', error);
      showLockMessage('Error scheduling update', 'error');
    } finally {
      setButtonLoading('confirmScheduleUpdateBtn', false);
    }
  }

  function collectScheduleSettings() {
    // Collect all settings from the form
    const maxBookings = (document.getElementById('maxBookings') as HTMLInputElement)?.value;
    const maxVisitors = (document.getElementById('maxVisitors') as HTMLInputElement)?.value;
    const maxVisitorPasses = (document.getElementById('maxVisitorPassesPerBooking') as HTMLInputElement)?.value;
    
    // Get operating days as an object with day names as keys (not an array)
    // This format is required for PostgreSQL's JSONB ? operator used in is_slot_valid_in_schedule
    const operatingDays: Record<string, boolean> = {};
    document.querySelectorAll('#operatingDays .toggle-chip.active').forEach((chip) => {
      const element = chip as HTMLElement;
      const day = element.dataset.day;
      if (day) {
        // Store the day name without spaces - database functions trim spaces anyway
        operatingDays[day] = true;
      }
    });
    
    // Get time slots
    const timeSlots: string[] = [];
    document.querySelectorAll('#timeSlotsGrid .time-slot-chip.active').forEach((chip) => {
      const element = chip as HTMLElement;
      const time = element.dataset.time;
      if (time) timeSlots.push(time);
    });
    
    // Get season range
    const seasonStartMonth = (document.getElementById('seasonStartMonth') as HTMLSelectElement)?.value;
    const seasonStartDay = (document.getElementById('seasonStartDay') as HTMLInputElement)?.value;
    const seasonEndMonth = (document.getElementById('seasonEndMonth') as HTMLSelectElement)?.value;
    const seasonEndDay = (document.getElementById('seasonEndDay') as HTMLInputElement)?.value;
    
    return [
      { key: 'max_bookings_per_slot', value: maxBookings },
      { key: 'max_bouquets_per_slot', value: maxVisitors },
      { key: 'max_visitor_passes_per_booking', value: maxVisitorPasses },
      { key: 'operating_days', value: JSON.stringify(operatingDays) },
      { key: 'time_slots', value: JSON.stringify(timeSlots) },
      { key: 'season_start_month', value: seasonStartMonth },
      { key: 'season_start_day', value: seasonStartDay },
      { key: 'season_end_month', value: seasonEndMonth },
      { key: 'season_end_day', value: seasonEndDay }
    ];
  }

  function enableAllFormInputs(enabled: boolean) {
    // Schedule settings
    const scheduleInputs = [
      '#maxBookings',
      '#maxVisitors',
      '#maxVisitorPassesPerBooking',
      '#operatingDays .toggle-chip',
      '#timeSlotsGrid .time-slot-chip',
      '#seasonStartMonth',
      '#seasonStartDay',
      '#seasonEndMonth',
      '#seasonEndDay'
    ];
    
    // Holiday management
    const holidayInputs = [
      '#holidayDate',
      '#holidayName',
      '#holidayReason',
      '#addHoliday',
      '#generateHolidays'
    ];
    
    // Booking range status
    const bookingRangeInputs = [
      '#extendRange',
      '#forceRefresh'
    ];
    
    // Apply disabled/enabled state to all form sections
    const allInputs = [...scheduleInputs, ...holidayInputs, ...bookingRangeInputs];
    
    allInputs.forEach(selector => {
      document.querySelectorAll(selector).forEach(el => {
        if (el instanceof HTMLInputElement || el instanceof HTMLButtonElement || el instanceof HTMLSelectElement) {
          el.disabled = !enabled;
        }
        if (!enabled) {
          el.classList.add('disabled');
        } else {
          el.classList.remove('disabled');
        }
      });
    });
    
    // Apply visual indication to admin sections, except pricing section
    document.querySelectorAll('.admin-section').forEach(section => {
      // Skip the pricing section - it should always be enabled
      if (section.querySelector('h2')?.textContent?.includes('Pricing Settings')) {
        return;
      }
      
      if (!enabled) {
        section.classList.add('section-disabled');
      } else {
        section.classList.remove('section-disabled');
      }
    });
  }

  function showLockMessage(message: string, type: 'success' | 'error') {
    const messageEl = document.getElementById('scheduleLockMessage');
    if (messageEl) {
      messageEl.textContent = message;
      messageEl.className = type === 'success' ? 'success-message' : 'error-message';
      messageEl.classList.remove('hidden');
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        messageEl.classList.add('hidden');
      }, 5000);
    }
  }

  function setButtonLoading(buttonId: string, isLoading: boolean) {
    const button = document.getElementById(buttonId);
    if (!button) return;

    const textSpan = button.querySelector('.btn-text');
    const spinnerSpan = button.querySelector('.btn-spinner');

    if (isLoading) {
      (button as HTMLButtonElement).disabled = true;
      if (textSpan) (textSpan as HTMLElement).style.display = 'none';
      if (spinnerSpan) (spinnerSpan as HTMLElement).style.display = 'flex';
    } else {
      (button as HTMLButtonElement).disabled = false;
      if (textSpan) (textSpan as HTMLElement).style.display = 'inline';
      if (spinnerSpan) (spinnerSpan as HTMLElement).style.display = 'none';
    }
  }

  function getMinDateTimeString() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
</script>


</head>
<body>
	<!-- Clean Header (hidden until login) -->
	<header class="header" id="admin-header" style="display: none;">
		<div class="header-content">
			<h1>Garden Management</h1>
			<div class="header-actions">
				<a href="/garden-mgmt/bookings" class="btn btn-secondary">View Bookings</a>
				<button id="logoutBtn" class="btn btn-secondary" onclick="logout()">Logout</button>
			</div>
		</div>
	</header>

	<!-- Login Form (shown initially) -->
	<div id="login-container" class="login-container">
		<div class="login-form">
			<h2>Admin Access</h2>
			<div id="login-error" class="error" style="display: none;"></div>
			<form id="login-form">
				<div class="form-group">
					<label for="admin-password">Password:</label>
					<input type="password" id="admin-password" required>
				</div>
				<button type="submit" class="btn btn-primary">Login</button>
			</form>
		</div>
	</div>

	<!-- Main Admin Container -->
	<div id="adminContent" class="admin-container hidden">
		<!-- Pricing Settings - Full Width Section -->
		<div class="admin-section pricing-section">
			<h2>Pricing Settings</h2>
			<div class="horizontal-fields-container">
				<div class="form-group">
					<label for="pricePerBouquet">Price per Bouquet (CAD):</label>
					<input type="number" id="pricePerBouquet" min="0" step="0.01" value="35.00">
				</div>
				
				<div class="form-group">
					<label for="pricePerVisitorPass">Price per Visitor Pass (CAD):</label>
					<input type="number" id="pricePerVisitorPass" min="0" step="0.01" value="5.00">
				</div>
				
				<div class="form-group">
					<label for="taxRate">Tax Rate (%):</label>
					<input type="number" id="taxRate" min="0" max="100" step="0.01" value="5.00">
				</div>
				
				<div class="form-group button-group">
					<button id="savePricing" class="btn btn-primary">
						<span class="btn-text">Save Pricing Settings</span>
						<span class="btn-spinner">
							<span class="spinner-icon"></span>
							Saving...
						</span>
					</button>
				</div>
			</div>
			<div id="pricingMessage" class="hidden"></div>
		</div>

		<div class="admin-sections">
			<!-- Left Column -->
			<div class="admin-column admin-column-left">
				<!-- Holiday Management -->
				<div class="admin-section">
					<h2>Holiday Management</h2>

					<div class="form-group">
						<label for="holidayDate">Add Holiday Date:</label>
						<input type="date" id="holidayDate">
					</div>

					<div class="form-group">
						<label for="holidayName">Holiday Name:</label>
						<input type="text" id="holidayName" placeholder="e.g., Day Off">
					</div>

					<div class="form-group">
						<label for="holidayReason">Reason (Optional):</label>
						<input type="text" id="holidayReason" placeholder="e.g., Maintenance, Personal">
					</div>

					<div class="admin-actions">
						<button id="addHoliday" class="btn btn-primary">
							<span class="btn-text">Add Holiday</span>
							<span class="btn-spinner">
								<span class="spinner-icon"></span>
								Adding...
							</span>
						</button>
						<button id="generateHolidays" class="btn btn-secondary">
							<span class="btn-text">Generate Common Holidays</span>
							<span class="btn-spinner">
								<span class="spinner-icon"></span>
								Generating...
							</span>
						</button>
					</div>

					<div id="holidayMessage" class="hidden"></div>

					<div class="holiday-table-container">
						<table class="holiday-table" id="holidayTable">
							<thead>
								<tr>
									<th>Date</th>
									<th>Holiday Name</th>
									<th>Reason</th>
									<th>Actions</th>
								</tr>
							</thead>
							<tbody id="holidayTableBody">
								<tr>
									<td colspan="4" class="loading-cell">Loading holidays...</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
			</div>

			<!-- Right Column -->
			<div class="admin-column admin-column-right">
				<!-- Schedule Settings -->
				<div class="admin-section">
					<h2>Schedule Settings</h2>

					<div class="form-group">
						<label for="maxBookings">Max Bookings per Slot:</label>
						<input type="number" id="maxBookings" min="1" value="3">
					</div>

					<div class="form-group">
						<label for="maxVisitors">Max Bouquets per Slot:</label>
						<input type="number" id="maxVisitors" min="1" value="10">
					</div>

					<div class="form-group">
						<label for="maxVisitorPassesPerBooking">Max Visitor Passes per Booking:</label>
						<input type="number" id="maxVisitorPassesPerBooking" min="0" value="8">
					</div>

					<div class="form-group">
						<label>Active Time Slots:</label>
						<div class="time-slots-grid" id="timeSlotsGrid">
							<!-- Time slots will be generated by JavaScript -->
						</div>
					</div>

					<div class="form-group">
						<label>Operating Days:</label>
						<div class="toggle-chips-group" id="operatingDays">
							<button type="button" class="toggle-chip" data-day="monday">Monday</button>
							<button type="button" class="toggle-chip" data-day="tuesday">Tuesday</button>
							<button type="button" class="toggle-chip" data-day="wednesday">Wednesday</button>
							<button type="button" class="toggle-chip" data-day="thursday">Thursday</button>
							<button type="button" class="toggle-chip" data-day="friday">Friday</button>
							<button type="button" class="toggle-chip" data-day="saturday">Saturday</button>
							<button type="button" class="toggle-chip" data-day="sunday">Sunday</button>
						</div>
					</div>

					<div class="form-group">
						<label>Season Range:</label>
						<div class="season-range-group">
							<div class="season-date">
								<label for="seasonStartMonth">Start:</label>
								<select id="seasonStartMonth" name="seasonStartMonth">
									<option value="1">January</option>
									<option value="2">February</option>
									<option value="3">March</option>
									<option value="4">April</option>
									<option value="5">May</option>
									<option value="6">June</option>
									<option value="7">July</option>
									<option value="8">August</option>
									<option value="9">September</option>
									<option value="10">October</option>
									<option value="11">November</option>
									<option value="12">December</option>
								</select>
								<input type="number" id="seasonStartDay" name="seasonStartDay" min="1" max="31" placeholder="Day">
							</div>
							<div class="season-date">
								<label for="seasonEndMonth">End:</label>
								<select id="seasonEndMonth" name="seasonEndMonth">
									<option value="1">January</option>
									<option value="2">February</option>
									<option value="3">March</option>
									<option value="4">April</option>
									<option value="5">May</option>
									<option value="6">June</option>
									<option value="7">July</option>
									<option value="8">August</option>
									<option value="9">September</option>
									<option value="10">October</option>
									<option value="11">November</option>
									<option value="12">December</option>
								</select>
								<input type="number" id="seasonEndDay" name="seasonEndDay" min="1" max="31" placeholder="Day">
							</div>
						</div>
						<p class="help-text">Define when your garden is open for the season (e.g., May 15 - September 30)</p>
					</div>

					<button id="saveSchedule" class="btn btn-primary">
						<span class="btn-text">Save Schedule Settings</span>
						<span class="btn-spinner">
							<span class="spinner-icon"></span>
							Saving...
						</span>
					</button>

					<div id="scheduleMessage" class="hidden"></div>
				</div>
				

				<!-- Booking Range Monitoring -->
				<div class="admin-section">
					<h2>Booking Range Status</h2>

					<div class="booking-range-status">
						<div class="status-grid">
							<div class="status-item">
								<label>Current Date:</label>
								<span id="currentDate">Loading...</span>
							</div>
							<div class="status-item">
								<label>Bookings Available Until:</label>
								<span id="maxFutureDate">Loading...</span>
							</div>
							<div class="status-item">
								<label>Days Remaining:</label>
								<span id="daysRemaining" class="days-remaining">Loading...</span>
							</div>
							<div class="status-item">
								<label>Total Open Days:</label>
								<span id="totalOpenDays">Loading...</span>
							</div>
							<div class="status-item">
								<label>Next Holiday:</label>
								<span id="nextHoliday">Loading...</span>
							</div>
						</div>

						<div class="range-actions">
							<button id="refreshRangeStatus" class="btn btn-secondary">
								<span class="btn-text">Refresh Status</span>
								<span class="btn-spinner">
									<span class="spinner-icon"></span>
									Refreshing...
								</span>
							</button>
							<button id="extendRange" class="btn btn-primary">
								<span class="btn-text">Extend Range</span>
								<span class="btn-spinner">
									<span class="spinner-icon"></span>
									Extending...
								</span>
							</button>
							<button id="forceRefresh" class="btn btn-warning">
								<span class="btn-text">Force Regenerate Schedule</span>
								<span class="btn-spinner">
									<span class="spinner-icon"></span>
									Regenerating...
								</span>
							</button>
						</div>

						<div id="rangeMessage" class="hidden"></div>
					</div>
				</div>
			</div>
		</div>
	</div>

	<script>
		let isLoggedIn = false;

		// DOM elements
		const loginContainer = document.getElementById('login-container') as HTMLElement;
		const adminContent = document.getElementById('adminContent') as HTMLElement;
		const adminHeader = document.getElementById('admin-header') as HTMLElement;
		const loginForm = document.getElementById('login-form') as HTMLFormElement;
		const loginError = document.getElementById('login-error') as HTMLElement;
		const adminPassword = document.getElementById('admin-password') as HTMLInputElement;
		// const logoutBtn = document.getElementById('logoutBtn') as HTMLButtonElement;

		// Event listeners
		if (loginForm) loginForm.addEventListener('submit', handleLogin);

		// Login handler
		async function handleLogin(event: Event): Promise<void> {
			event.preventDefault();

			if (!adminPassword || !loginError) {
				console.error('Required elements not found');
				return;
			}

			const password = adminPassword.value;

			try {
				// Get admin password from settings
				const response = await fetch('/api/admin/verify-password', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ password })
				});

				const result = await response.json();

				if (result.success) {
					isLoggedIn = true;

					if (loginContainer) loginContainer.style.display = 'none';
					if (adminContent) {
						adminContent.classList.remove('hidden');
						adminContent.style.display = 'block';
					}
					if (adminHeader) adminHeader.style.display = 'block';

					loadHolidays();
					loadBookingRangeStatus();
					// Add a small delay to ensure DOM is ready
					setTimeout(() => {
						// Test: Manually activate Thursday chip to test CSS
						const thursdayChip = document.querySelector('[data-day="thursday"]') as HTMLElement;
						if (thursdayChip) {
							thursdayChip.classList.add('active');
							console.log('Test: Manually activated Thursday chip for CSS testing');
						}

						loadScheduleSettings();
						loadPricingSettings();
						setupOperatingDaysHandlers();
					}, 100);
				} else {
					showLoginError('Invalid password');
				}
			} catch (error) {
				console.error('Login error:', error);
				showLoginError('Login failed. Please try again.');
			}
		}

		// Show login error
		function showLoginError(message: string): void {
			if (loginError) {
				loginError.textContent = message;
				loginError.style.display = 'block';
			}
		}

		function logout(): void {
			isLoggedIn = false;

			if (adminContent) {
				adminContent.classList.add('hidden');
				adminContent.style.display = 'none';
			}
			if (adminHeader) adminHeader.style.display = 'none';
			if (loginContainer) loginContainer.style.display = 'flex';
			if (adminPassword) adminPassword.value = '';
			if (loginError) loginError.style.display = 'none';
		}



		async function loadHolidays(): Promise<void> {
			try {
				const response = await fetch('/api/admin/holidays');
				const holidays = await response.json();

				const holidayTableBody = document.getElementById('holidayTableBody');

				if (!holidayTableBody) {
					console.error('Holiday table body element not found');
					return;
				}

				if (holidays.length === 0) {
					holidayTableBody.innerHTML = '<tr><td colspan="5" class="no-data-cell">No holidays configured.</td></tr>';
					return;
				}

				holidayTableBody.innerHTML = holidays.map((holiday: any) => {
					const isDisabled = holiday.is_disabled || false;
					const isAutoGenerated = holiday.is_auto_generated || false;
					// Fix timezone issue by parsing date as local date
					const dateParts = holiday.date.split('-');
					const localDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
					const formattedDate = localDate.toLocaleDateString('en-US', {
						weekday: 'short',
						month: 'short',
						day: 'numeric',
						year: 'numeric'
					});

					return `
						<tr class="${isDisabled ? 'holiday-disabled' : ''}">
							<td class="date-cell">${formattedDate}</td>
							<td class="name-cell">
								${isDisabled ? '<span class="disabled-indicator">🚫</span>' : ''}
								${holiday.name}
							</td>
							<td class="type-cell">
								<span class="badge ${isAutoGenerated ? 'badge-auto' : 'badge-manual'}">
									${isAutoGenerated ? 'Auto' : 'Manual'}
								</span>
							</td>
							<td class="status-cell">
								<span class="badge ${isDisabled ? 'badge-disabled' : 'badge-active'}">
									${isDisabled ? 'Disabled' : 'Active'}
								</span>
							</td>
							<td class="actions-cell">
								${isAutoGenerated ?
									(isDisabled ?
										`<button class="btn btn-sm btn-success" onclick="enableHoliday('${holiday.id}')">Enable</button>` :
										`<button class="btn btn-sm btn-warning" onclick="disableHoliday('${holiday.id}')">Disable</button>`
									) :
									`<button class="btn btn-sm btn-danger" onclick="removeHoliday('${holiday.id}')">Remove</button>`
								}
							</td>
						</tr>
					`;
				}).join('');
			} catch (error) {
				console.error('Error loading holidays:', error);
				const holidayList = document.getElementById('holidayList');
				if (holidayList) {
					holidayList.innerHTML = '<p>Error loading holidays.</p>';
				}
			}
		}

		async function addHoliday(): Promise<void> {
			const dateElement = document.getElementById('holidayDate') as HTMLInputElement;
			const nameElement = document.getElementById('holidayName') as HTMLInputElement;
			const reasonElement = document.getElementById('holidayReason') as HTMLInputElement;
			const messageDiv = document.getElementById('holidayMessage');

			if (!dateElement || !nameElement || !messageDiv) {
				console.error('Required elements not found');
				return;
			}

			const date = dateElement.value;
			const name = nameElement.value;
			const reason = reasonElement?.value || '';

			if (!date) {
				showMessage(messageDiv, 'Please select a date.', 'error');
				return;
			}

			if (!name) {
				showMessage(messageDiv, 'Please enter a holiday name.', 'error');
				return;
			}
			
			// Validate date is not in the past
			const selectedDate = new Date(date);
			const today = new Date();
			today.setHours(0, 0, 0, 0);
			
			if (selectedDate < today) {
				showMessage(messageDiv, 'Cannot add holidays in the past.', 'error');
				return;
			}

			// Show loading state
			setButtonLoading('addHoliday', true);

			try {
				const response = await fetch('/api/admin/holidays', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ date, name, reason })
				});

				const result = await response.json();

				if (result.success) {
					showMessage(messageDiv, 'Holiday added successfully!', 'success');
					dateElement.value = '';
					nameElement.value = '';
					loadHolidays();
				} else {
					showMessage(messageDiv, result.error || 'Failed to add holiday.', 'error');
				}
			} catch (error) {
				console.error('Error adding holiday:', error);
				showMessage(messageDiv, 'Error adding holiday.', 'error');
			} finally {
				// Hide loading state
				setButtonLoading('addHoliday', false);
			}
		}

		async function generateFutureHolidays(): Promise<void> {
			const messageDiv = document.getElementById('holidayMessage');
			if (!messageDiv) return;

			if (!confirm('This will generate automatic holidays for the next 3 years. Continue?')) {
				return;
			}

			// Show loading state
			setButtonLoading('generateHolidays', true);

			try {
				showMessage(messageDiv, 'Generating holidays...', 'success');

				const response = await fetch('/api/admin/holidays/generate', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' }
				});

				const result = await response.json();

				if (result.success) {
					showMessage(messageDiv, `Successfully generated holidays for ${result.years_generated} years!`, 'success');
					loadHolidays(); // Refresh the list
				} else {
					showMessage(messageDiv, result.error || 'Failed to generate holidays.', 'error');
				}
			} catch (error) {
				console.error('Error generating holidays:', error);
				showMessage(messageDiv, 'An error occurred while generating holidays.', 'error');
			} finally {
				// Hide loading state
				setButtonLoading('generateHolidays', false);
			}
		}

		async function removeHoliday(holidayId: string): Promise<void> {
			if (!confirm('Are you sure you want to remove this holiday? This action cannot be undone.')) return;

			try {
				const response = await fetch(`/api/admin/holidays/${holidayId}`, {
					method: 'DELETE'
				});

				const result = await response.json();

				if (result.success) {
					loadHolidays();
				} else {
					alert('Failed to remove holiday: ' + (result.error || 'Unknown error'));
				}
			} catch (error) {
				console.error('Error removing holiday:', error);
				alert('Error removing holiday.');
			}
		}

		async function disableHoliday(holidayId: string): Promise<void> {
			if (!confirm('Are you sure you want to disable this automatic holiday? It can be re-enabled later.')) return;

			// Find the button that was clicked and show loading state
			const button = document.querySelector(`button[onclick="disableHoliday('${holidayId}')"]`) as HTMLButtonElement;
			if (button) {
				button.disabled = true;
				button.innerHTML = '<span class="btn-spinner"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 11-6.219-8.56"/></svg></span> Disabling...';
			}

			try {
				const response = await fetch(`/api/admin/holidays/${holidayId}`, {
					method: 'DELETE'
				});

				const result = await response.json();

				if (result.success) {
					loadHolidays();
				} else {
					alert('Failed to disable holiday: ' + (result.error || 'Unknown error'));
				}
			} catch (error) {
				console.error('Error disabling holiday:', error);
				alert('Error disabling holiday.');
			} finally {
				// Reset button state (will be replaced by loadHolidays anyway)
				if (button) {
					button.disabled = false;
					button.innerHTML = 'Disable';
				}
			}
		}

		async function enableHoliday(holidayId: string): Promise<void> {
			// Find the button that was clicked and show loading state
			const button = document.querySelector(`button[onclick="enableHoliday('${holidayId}')"]`) as HTMLButtonElement;
			if (button) {
				button.disabled = true;
				button.innerHTML = '<span class="btn-spinner"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 11-6.219-8.56"/></svg></span> Enabling...';
			}

			try {
				const response = await fetch(`/api/admin/holidays/${holidayId}/enable`, {
					method: 'POST'
				});

				const result = await response.json();

				if (result.success) {
					loadHolidays();
				} else {
					alert('Failed to enable holiday: ' + (result.error || 'Unknown error'));
				}
			} catch (error) {
				console.error('Error enabling holiday:', error);
				alert('Error enabling holiday.');
			} finally {
				// Reset button state (will be replaced by loadHolidays anyway)
				if (button) {
					button.disabled = false;
					button.innerHTML = 'Enable';
				}
			}
		}

		// Generate 24-hour time slots grid
		function generateTimeSlotsGrid(): void {
			console.log('generateTimeSlotsGrid called'); // Debug log
			const timeSlotsGrid = document.getElementById('timeSlotsGrid');
			if (!timeSlotsGrid) {
				console.error('timeSlotsGrid element not found!'); // Debug log
				return;
			}
			console.log('timeSlotsGrid element found:', timeSlotsGrid); // Debug log

			const hours: Array<{ value: string; hour24: number }> = [];
			for (let i = 0; i < 24; i++) {
				const hour12 = i === 0 ? 12 : i > 12 ? i - 12 : i;
				const ampm = i < 12 ? 'AM' : 'PM';
				const timeString = `${hour12}:00 ${ampm}`;
				hours.push({ value: timeString, hour24: i });
			}

			timeSlotsGrid.innerHTML = hours.map(time => `
				<button type="button" class="time-slot-chip" data-time="${time.value}">
					${time.value}
				</button>
			`).join('');

			console.log('Generated', hours.length, 'time slot chips'); // Debug log

			// Test: Manually activate a few chips to test CSS
			const testChips = timeSlotsGrid.querySelectorAll('.time-slot-chip');
			if (testChips.length > 0) {
				testChips[0].classList.add('active'); // 12:00 AM
				testChips[10].classList.add('active'); // 10:00 AM
				console.log('Test: Manually activated first two chips for CSS testing');
			}

			// Add click handlers for time slots
			timeSlotsGrid.addEventListener('click', handleTimeSlotToggle);
		}

		async function handleTimeSlotToggle(event: Event): Promise<void> {
			const target = event.target as HTMLElement;
			if (!target.classList.contains('time-slot-chip')) return;

			const timeValue = target.dataset.time;
			const isActive = target.classList.contains('active');
			const action = isActive ? 'remove' : 'add';

			if (!confirm(`Are you sure you want to ${action} ${timeValue} ${isActive ? 'from' : 'to'} the available time slots?`)) {
				return;
			}

			target.classList.toggle('active');
		}

		async function loadScheduleSettings(): Promise<void> {
			try {
				const response = await fetch('/api/admin/settings');
				const settings = await response.json();

				console.log('Loaded settings:', settings); // Debug log

				// Generate time slots grid first
				generateTimeSlotsGrid();

				// Load operating days
				console.log('Raw operating_days from DB:', settings.operating_days, 'Type:', typeof settings.operating_days); // Debug log
				let operatingDays = [];

				if (Array.isArray(settings.operating_days)) {
					// Data is already an array
					operatingDays = settings.operating_days;
					console.log('Operating days already an array:', operatingDays); // Debug log
				} else if (typeof settings.operating_days === 'string') {
					// Data is a JSON string, parse it
					try {
						operatingDays = JSON.parse(settings.operating_days || '[]');
						console.log('Parsed operating days from JSON:', operatingDays); // Debug log
					} catch (error) {
						console.error('Error parsing operating_days JSON:', error);
						operatingDays = [];
					}
				} else {
					console.log('Operating days is neither array nor string, using empty array');
					operatingDays = [];
				}

				const dayChips = document.querySelectorAll('#operatingDays .toggle-chip');
				console.log('Found', dayChips.length, 'day chips'); // Debug log
				dayChips.forEach((chip: Element) => {
					const chipElement = chip as HTMLElement;
					const dayValue = chipElement.dataset.day;
					chipElement.classList.remove('active'); // Clear existing state
					if (operatingDays.includes(dayValue)) {
						chipElement.classList.add('active');
						console.log('Activated day:', dayValue, 'Classes:', chipElement.className); // Debug log
					} else {
						console.log('Day not active:', dayValue); // Debug log
					}
				});

				// Load and set active time slots
				console.log('Raw time_slots from DB:', settings.time_slots, 'Type:', typeof settings.time_slots); // Debug log
				let timeSlots = [];

				if (Array.isArray(settings.time_slots)) {
					// Data is already an array
					timeSlots = settings.time_slots;
					console.log('Time slots already an array:', timeSlots); // Debug log
				} else if (typeof settings.time_slots === 'string') {
					// Data is a JSON string, parse it
					try {
						timeSlots = JSON.parse(settings.time_slots || '[]');
						console.log('Parsed time slots from JSON:', timeSlots); // Debug log
					} catch (error) {
						console.error('Error parsing time_slots JSON:', error);
						timeSlots = [];
					}
				} else {
					console.log('Time slots is neither array nor string, using empty array');
					timeSlots = [];
				}

				const timeSlotChips = document.querySelectorAll('#timeSlotsGrid .time-slot-chip');
				console.log('Found', timeSlotChips.length, 'time slot chips'); // Debug log
				timeSlotChips.forEach((chip: Element) => {
					const chipElement = chip as HTMLElement;
					const timeValue = chipElement.dataset.time;
					chipElement.classList.remove('active'); // Clear existing state
					if (timeSlots.includes(timeValue)) {
						chipElement.classList.add('active');
						console.log('Activated time slot:', timeValue, 'Classes:', chipElement.className); // Debug log
					} else {
						console.log('Time slot not active:', timeValue); // Debug log
					}
				});

				// Load capacity settings
				const maxBookingsElement = document.getElementById('maxBookings') as HTMLInputElement;
				const maxVisitorsElement = document.getElementById('maxVisitors') as HTMLInputElement;
				const maxVisitorPassesElement = document.getElementById('maxVisitorPassesPerBooking') as HTMLInputElement;

				// Parse values that might be double-JSON-encoded
				if (maxBookingsElement && settings.max_bookings_per_slot) {
					let value = settings.max_bookings_per_slot;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					maxBookingsElement.value = value;
					console.log('Set maxBookings to:', value);
				}

				if (maxVisitorsElement && settings.max_bouquets_per_slot) {
					let value = settings.max_bouquets_per_slot;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					maxVisitorsElement.value = value;
					console.log('Set maxVisitors to:', value);
				}

				if (maxVisitorPassesElement && settings.max_visitor_passes_per_booking) {
					let value = settings.max_visitor_passes_per_booking;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					maxVisitorPassesElement.value = value;
					console.log('Set maxVisitorPassesPerBooking to:', value);
				}

				// Load seasonal settings
				const seasonStartMonthElement = document.getElementById('seasonStartMonth') as HTMLSelectElement;
				const seasonStartDayElement = document.getElementById('seasonStartDay') as HTMLInputElement;
				const seasonEndMonthElement = document.getElementById('seasonEndMonth') as HTMLSelectElement;
				const seasonEndDayElement = document.getElementById('seasonEndDay') as HTMLInputElement;

				if (seasonStartMonthElement && settings.season_start_month) {
					let value = settings.season_start_month;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					seasonStartMonthElement.value = value;
					console.log('Set seasonStartMonth to:', value);
				}
				if (seasonStartDayElement && settings.season_start_day) {
					let value = settings.season_start_day;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					seasonStartDayElement.value = value;
					console.log('Set seasonStartDay to:', value);
				}
				if (seasonEndMonthElement && settings.season_end_month) {
					let value = settings.season_end_month;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					seasonEndMonthElement.value = value;
					console.log('Set seasonEndMonth to:', value);
				}
				if (seasonEndDayElement && settings.season_end_day) {
					let value = settings.season_end_day;
					// Handle double-JSON encoding
					if (typeof value === 'string' && value.startsWith('"') && value.endsWith('"')) {
						value = JSON.parse(value);
					}
					seasonEndDayElement.value = value;
					console.log('Set seasonEndDay to:', value);
				}

			} catch (error) {
				console.error('Error loading settings:', error);
			}
		}

		// Add click handlers for operating days
		function setupOperatingDaysHandlers(): void {
			const operatingDaysContainer = document.getElementById('operatingDays');
			if (!operatingDaysContainer) return;

			operatingDaysContainer.addEventListener('click', async (event: Event) => {
				const target = event.target as HTMLElement;
				if (!target.classList.contains('toggle-chip')) return;

				const dayValue = target.dataset.day;
				const isActive = target.classList.contains('active');
				const action = isActive ? 'close' : 'open';

				if (!confirm(`Are you sure you want to ${action} the business on ${dayValue}s?`)) {
					return;
				}

				target.classList.toggle('active');
			});
		}

		async function updateScheduleSettings(): Promise<void> {
			const messageDiv = document.getElementById('scheduleMessage');

			if (!messageDiv) {
				console.error('Schedule message element not found');
				return;
			}

			// Show loading state
			setButtonLoading('saveSchedule', true);

			try {
				// Get operating days from active chips
				const operatingDays: string[] = [];
				const activeDayChips = document.querySelectorAll('#operatingDays .toggle-chip.active');
				activeDayChips.forEach((chip: Element) => {
					const chipElement = chip as HTMLElement;
					const dayValue = chipElement.dataset.day;
					if (dayValue) operatingDays.push(dayValue);
				});

				// Get time slots from active chips
				const timeSlots: string[] = [];
				const activeTimeChips = document.querySelectorAll('#timeSlotsGrid .time-slot-chip.active');
				activeTimeChips.forEach((chip: Element) => {
					const chipElement = chip as HTMLElement;
					const timeValue = chipElement.dataset.time;
					if (timeValue) timeSlots.push(timeValue);
				});

				const maxBookingsInput = document.getElementById('maxBookings') as HTMLInputElement;
				const maxVisitorsInput = document.getElementById('maxVisitors') as HTMLInputElement;
				const maxVisitorPassesInput = document.getElementById('maxVisitorPassesPerBooking') as HTMLInputElement;
				const seasonStartMonthInput = document.getElementById('seasonStartMonth') as HTMLSelectElement;
				const seasonStartDayInput = document.getElementById('seasonStartDay') as HTMLInputElement;
				const seasonEndMonthInput = document.getElementById('seasonEndMonth') as HTMLSelectElement;
				const seasonEndDayInput = document.getElementById('seasonEndDay') as HTMLInputElement;

				if (!maxBookingsInput || !maxVisitorsInput || !maxVisitorPassesInput) {
					showMessage(messageDiv, 'Capacity elements not found.', 'error');
					return;
				}

				if (!seasonStartMonthInput || !seasonStartDayInput || !seasonEndMonthInput || !seasonEndDayInput) {
					showMessage(messageDiv, 'Season range elements not found.', 'error');
					return;
				}

				const maxBookings = parseInt(maxBookingsInput.value);
				const maxVisitors = parseInt(maxVisitorsInput.value);
				const maxVisitorPasses = parseInt(maxVisitorPassesInput.value);
				const seasonStartMonth = parseInt(seasonStartMonthInput.value);
				const seasonStartDay = parseInt(seasonStartDayInput.value);
				const seasonEndMonth = parseInt(seasonEndMonthInput.value);
				const seasonEndDay = parseInt(seasonEndDayInput.value);
				
				// Additional validation for numeric values
				if (isNaN(maxBookings) || maxBookings < 1) {
					showMessage(messageDiv, 'Max bookings per slot must be at least 1.', 'error');
					return;
				}

				if (isNaN(maxVisitors) || maxVisitors < 1) {
					showMessage(messageDiv, 'Max bouquets per slot must be at least 1.', 'error');
					return;
				}

				if (isNaN(maxVisitorPasses) || maxVisitorPasses < 0) {
					showMessage(messageDiv, 'Max visitor passes per booking must be 0 or greater.', 'error');
					return;
				}
				
				// Validate season dates
				if (isNaN(seasonStartMonth) || seasonStartMonth < 1 || seasonStartMonth > 12 ||
					isNaN(seasonStartDay) || seasonStartDay < 1 || seasonStartDay > 31) {
					showMessage(messageDiv, 'Invalid season start date.', 'error');
					return;
				}
				
				if (isNaN(seasonEndMonth) || seasonEndMonth < 1 || seasonEndMonth > 12 ||
					isNaN(seasonEndDay) || seasonEndDay < 1 || seasonEndDay > 31) {
					showMessage(messageDiv, 'Invalid season end date.', 'error');
					return;
				}

				if (operatingDays.length === 0) {
					showMessage(messageDiv, 'Please select at least one operating day.', 'error');
					return;
				}

				if (timeSlots.length === 0) {
					showMessage(messageDiv, 'Please enter at least one time slot.', 'error');
					return;
				}

				// Debug logging
				console.log('Submitting schedule settings:');
				console.log('Operating days:', operatingDays);
				console.log('Time slots:', timeSlots);
				console.log('Max bookings:', maxBookings);
				console.log('Max visitors:', maxVisitors);
				console.log('Max visitor passes:', maxVisitorPasses);
				console.log('Season start:', seasonStartMonth, seasonStartDay);
				console.log('Season end:', seasonEndMonth, seasonEndDay);

				const response = await fetch('/api/admin/settings', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						operating_days: operatingDays,
						time_slots: timeSlots,
						max_bookings_per_slot: maxBookings,
						max_visitors_per_slot: maxVisitors, // Keep for API compatibility
						max_visitor_passes_per_booking: maxVisitorPasses,
						season_start_month: seasonStartMonth,
						season_start_day: seasonStartDay,
						season_end_month: seasonEndMonth,
						season_end_day: seasonEndDay
					})
				});

				const result = await response.json();

				if (result.success) {
					showMessage(messageDiv, 'Schedule settings updated successfully! Future bookings will use the new schedule.', 'success');
				} else {
					showMessage(messageDiv, result.error || 'Failed to update settings.', 'error');
				}
			} catch (error) {
				console.error('Error updating settings:', error);
				showMessage(messageDiv, 'Error updating settings.', 'error');
			} finally {
				// Hide loading state
				setButtonLoading('saveSchedule', false);
			}
		}

		function showMessage(element: HTMLElement, message: string, type: 'error' | 'success'): void {
			element.textContent = message;
			element.className = type === 'error' ? 'error-message' : 'success-message';
			element.classList.remove('hidden');

			setTimeout(() => {
				element.classList.add('hidden');
			}, 5000);
		}

		// Button loading state helpers
		function setButtonLoading(buttonId: string, loading: boolean): void {
			const button = document.getElementById(buttonId) as HTMLButtonElement;
			if (!button) return;

			const textSpan = button.querySelector('.btn-text') as HTMLElement;
			const spinnerSpan = button.querySelector('.btn-spinner') as HTMLElement;

			if (loading) {
				button.disabled = true;
				if (textSpan) textSpan.style.display = 'none';
				if (spinnerSpan) spinnerSpan.style.display = 'flex';
			} else {
				button.disabled = false;
				if (textSpan) textSpan.style.display = 'inline';
				if (spinnerSpan) spinnerSpan.style.display = 'none';
			}
		}

		// Booking Range Status Functions
		async function loadBookingRangeStatus(): Promise<void> {
			try {
				const response = await fetch('/api/admin/extend-booking-range');
				const result = await response.json();

				if (result.success) {
					updateBookingRangeDisplay(result.status);
				} else {
					console.error('Failed to load booking range status:', result.error);
					showRangeMessage('Failed to load booking range status.', 'error');
				}
			} catch (error) {
				console.error('Error loading booking range status:', error);
				showRangeMessage('Error loading booking range status.', 'error');
			}
		}

		function updateBookingRangeDisplay(status: any): void {
			// Update display elements
			const currentDate = document.getElementById('currentDate');
			const maxFutureDate = document.getElementById('maxFutureDate');
			const daysRemaining = document.getElementById('daysRemaining');
			const totalOpenDays = document.getElementById('totalOpenDays');
			const totalTimeSlots = document.getElementById('totalTimeSlots');
			const extensionStatus = document.getElementById('extensionStatus');

			if (currentDate) currentDate.textContent = status.current_date;
			if (maxFutureDate) maxFutureDate.textContent = status.max_future_date;
			if (totalOpenDays) totalOpenDays.textContent = status.total_open_days.toString();
			if (totalTimeSlots) totalTimeSlots.textContent = status.total_time_slots.toString();

			// Update days remaining with color coding
			if (daysRemaining) {
				daysRemaining.textContent = `${status.days_remaining} days`;
				daysRemaining.className = 'days-remaining';

				if (status.days_remaining < 180) {
					daysRemaining.classList.add('danger');
				} else if (status.days_remaining < 300) {
					daysRemaining.classList.add('warning');
				}
			}

			// Update extension status
			if (extensionStatus) {
				if (status.needs_extension) {
					extensionStatus.textContent = 'Extension Needed';
					extensionStatus.className = 'extension-status danger';
				} else if (status.days_remaining < 300) {
					extensionStatus.textContent = 'Monitor Closely';
					extensionStatus.className = 'extension-status warning';
				} else {
					extensionStatus.textContent = 'Healthy Range';
					extensionStatus.className = 'extension-status good';
				}
			}
		}

		async function refreshRangeStatus(): Promise<void> {
			setButtonLoading('refreshRangeStatus', true);
			await loadBookingRangeStatus();
			setButtonLoading('refreshRangeStatus', false);
		}

		async function forceRegenerateSchedule(): Promise<void> {
			const messageDiv = document.getElementById('rangeMessage');
			if (!messageDiv) return;

			if (!confirm('This will COMPLETELY REGENERATE all future schedule data. This is only necessary for major changes. Continue?')) {
				return;
			}

			setButtonLoading('forceRefresh', true);

			try {
				showRangeMessage('Force regenerating schedule...', 'success');

				const response = await fetch('/api/admin/force-refresh', {
					method: 'POST'
				});

				const result = await response.json();

				if (result.success) {
					showRangeMessage(`Schedule successfully regenerated! Created ${result.generatedDays} days and ${result.generatedSlots} time slots.`, 'success');
					// Refresh the status display
					await loadBookingRangeStatus();
				} else {
					showRangeMessage(result.error || 'Failed to regenerate schedule.', 'error');
				}
			} catch (error) {
				console.error('Error force regenerating schedule:', error);
				showRangeMessage('Error regenerating schedule.', 'error');
			} finally {
				setButtonLoading('forceRefresh', false);
			}
		}

		async function extendBookingRange(): Promise<void> {
			const messageDiv = document.getElementById('rangeMessage');
			if (!messageDiv) return;

			setButtonLoading('extendRange', true);

			try {
				const response = await fetch('/api/admin/extend-booking-range', {
					method: 'POST'
				});

				const result = await response.json();

				if (result.success) {
					showRangeMessage(result.message, 'success');
					// Refresh the status display
					await loadBookingRangeStatus();
				} else {
					showRangeMessage(result.error || 'Failed to extend booking range.', 'error');
				}
			} catch (error) {
				console.error('Error extending booking range:', error);
				showRangeMessage('Error extending booking range.', 'error');
			} finally {
				setButtonLoading('extendRange', false);
			}
		}

		function showRangeMessage(message: string, type: 'error' | 'success'): void {
			const messageDiv = document.getElementById('rangeMessage');
			if (!messageDiv) return;

			messageDiv.textContent = message;
			messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
			messageDiv.classList.remove('hidden');

			setTimeout(() => {
				messageDiv.classList.add('hidden');
			}, 5000);
		}



		// Add event listeners for booking range buttons
		const refreshRangeBtn = document.getElementById('refreshRangeStatus');
		const extendRangeBtn = document.getElementById('extendRange');
		const forceRefreshBtn = document.getElementById('forceRefresh');

		if (refreshRangeBtn) refreshRangeBtn.addEventListener('click', refreshRangeStatus);
		if (extendRangeBtn) extendRangeBtn.addEventListener('click', extendBookingRange);
		if (forceRefreshBtn) forceRefreshBtn.addEventListener('click', forceRegenerateSchedule);

		// Add event listeners for settings save buttons
		const saveScheduleBtn = document.getElementById('saveSchedule');
		const savePricingBtn = document.getElementById('savePricing');

		if (saveScheduleBtn) saveScheduleBtn.addEventListener('click', updateScheduleSettings);
		if (savePricingBtn) savePricingBtn.addEventListener('click', updatePricingSettings);
		
		// Add event listeners for holiday management buttons
		const addHolidayBtn = document.getElementById('addHoliday');
		const generateHolidaysBtn = document.getElementById('generateHolidays');
		
		if (addHolidayBtn) addHolidayBtn.addEventListener('click', addHoliday);
		if (generateHolidaysBtn) generateHolidaysBtn.addEventListener('click', generateFutureHolidays);

		// Pricing Settings Functions
		async function loadPricingSettings(): Promise<void> {
			try {
				const response = await fetch('/api/settings/pricing');
				const data = await response.json();

				const bouquetPriceInput = document.getElementById('pricePerBouquet') as HTMLInputElement;
				const visitorPassPriceInput = document.getElementById('pricePerVisitorPass') as HTMLInputElement;

				if (bouquetPriceInput) {
					bouquetPriceInput.value = data.price_per_bouquet || '35.00';
				}

				if (visitorPassPriceInput) {
					visitorPassPriceInput.value = data.price_per_visitor_pass || '5.00';
				}

				// Note: max_visitor_passes_per_booking is now handled by loadScheduleSettings() only
				// to avoid conflicts between the two loading functions

				console.log('Loaded pricing settings:', data);
			} catch (error) {
				console.error('Error loading pricing settings:', error);
				// Set fallback values
				const bouquetPriceInput = document.getElementById('pricePerBouquet') as HTMLInputElement;
				const visitorPassPriceInput = document.getElementById('pricePerVisitorPass') as HTMLInputElement;

				if (bouquetPriceInput) {
					bouquetPriceInput.value = '35.00';
				}
				if (visitorPassPriceInput) {
					visitorPassPriceInput.value = '5.00';
				}
				// Note: max_visitor_passes_per_booking fallback is handled by loadScheduleSettings()
			}
		}

		async function updatePricingSettings(): Promise<void> {
			const bouquetPriceInput = document.getElementById('pricePerBouquet') as HTMLInputElement;
			const visitorPassPriceInput = document.getElementById('pricePerVisitorPass') as HTMLInputElement;
			const maxVisitorPassesInput = document.getElementById('maxVisitorPassesPerBooking') as HTMLInputElement;
			const messageDiv = document.getElementById('pricingMessage');

			if (!bouquetPriceInput || !visitorPassPriceInput || !maxVisitorPassesInput || !messageDiv) return;

			const bouquetPrice = parseFloat(bouquetPriceInput.value);
			const visitorPassPrice = parseFloat(visitorPassPriceInput.value);
			const maxVisitorPasses = parseInt(maxVisitorPassesInput.value);

			// Validate bouquet price
			if (isNaN(bouquetPrice) || bouquetPrice < 1 || bouquetPrice > 200) {
				showMessage(messageDiv, 'Bouquet price must be between $1.00 and $200.00', 'error');
				return;
			}

			// Validate visitor pass price
			if (isNaN(visitorPassPrice) || visitorPassPrice < 0 || visitorPassPrice > 100) {
				showMessage(messageDiv, 'Visitor pass price must be between $0.00 and $100.00', 'error');
				return;
			}

			// Validate visitor pass limit
			if (isNaN(maxVisitorPasses) || maxVisitorPasses < 0) {
				showMessage(messageDiv, 'Visitor pass limit must be 0 or greater', 'error');
				return;
			}

			setButtonLoading('savePricing', true);

			try {
				const response = await fetch('/api/settings/pricing', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						price_per_bouquet: bouquetPrice.toFixed(2),
						price_per_visitor_pass: visitorPassPrice.toFixed(2),
						max_visitor_passes_per_booking: maxVisitorPasses
					})
				});

				const result = await response.json();

				if (result.success) {
					const bouquetMsg = result.price_per_bouquet ? `Bouquet: $${result.price_per_bouquet}` : '';
					const visitorMsg = result.price_per_visitor_pass ? `Visitor Pass: $${result.price_per_visitor_pass}` : '';
					const limitMsg = result.max_visitor_passes_per_booking ? `Max Visitor Passes: ${result.max_visitor_passes_per_booking}` : '';
					const messages = [bouquetMsg, visitorMsg, limitMsg].filter(Boolean).join(', ');
					showMessage(messageDiv, `Pricing updated successfully! ${messages}`, 'success');
				} else {
					showMessage(messageDiv, result.error || 'Failed to update pricing.', 'error');
				}
			} catch (error) {
				console.error('Error updating pricing:', error);
				showMessage(messageDiv, 'Failed to update pricing. Please try again.', 'error');
			} finally {
				setButtonLoading('savePricing', false);
			}
		}

		// Make functions globally available for onclick handlers
		(window as any).logout = logout;
		(window as any).addHoliday = addHoliday;
		(window as any).removeHoliday = removeHoliday;
		(window as any).disableHoliday = disableHoliday;
		(window as any).enableHoliday = enableHoliday;
		(window as any).updateScheduleSettings = updateScheduleSettings;
		(window as any).updatePricingSettings = updatePricingSettings;
		(window as any).refreshRangeStatus = refreshRangeStatus;
		(window as any).extendBookingRange = extendBookingRange;
		(window as any).forceRegenerateSchedule = forceRegenerateSchedule;

		console.log('Garden management page JavaScript loaded');
	</script>
</body>
</html>
